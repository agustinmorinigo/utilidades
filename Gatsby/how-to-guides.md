# **LOCAL DEVELOPMENT**
___
&nbsp;
&nbsp;

## Environment Variables

- Desarrollo: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **.env.development**
- Producción: &nbsp;&nbsp;&nbsp;&nbsp; **.env.production**

Para cargarlos en Node.js, agregar el siguiente código en la parte superior del **gatsby-config.js**:

``` javascript
require('dotenv').config({
  path: `.env.${process.env.NODE_ENV}`
})
```

Esto habilita a poder usar las variables de entorno en cualquier archivo **gatsby-\*.js**. Por ejemplo, en **gatsby-config.js**:

``` javascript
require('dotenv').config({
  path: `.env.${process.env.NODE_ENV}`,
})

module.exports = {
  plugins: [
    {
      resolve: 'gatsby-source-custom',
      options: {
        apiKey: process.env.API_KEY,
      },
    },
  ],
}
```

&nbsp;
&nbsp;

##### Accessing Environment Variables in the browser.
Por defecto, las variables de entorno solo están disponibles en Node.js. Es decir, NO se pueden ver o leer en el navegador.
Para hacer que una variable pueda ser leída por el navegador, se debe agregar el prefijo ```GATSBY_``` delante del nombre de la variable.
De esta forma, la variable ```GATSBY_API_URL``` estará disponible en el navegador, pero ```API_KEY``` NO.

Sintáxis para leer una variable de entorno en los archivos: ```process.env.nombreDeVariable```.

&nbsp;
&nbsp;

##### Add ```.env*``` files to ```.gitignore```
NUNCA hay que agregar los .env a GIT, ya que tienen información sensible.
Debido a esto, debemos agregar en **.gitignore** el texto ```.env*``` para que GIT ignore dichos archivos.
De esta forma, debemos configurar manualmente las variables de entorno **locales** y en **Gatsby Cloud**.

&nbsp;
&nbsp;

## GraphQL Typegen
Esta herramienta nos sirve para automatizar los tipados en GraphQL.
Con esto, creamos queries más rápido y seguro.

&nbsp;
&nbsp;

##### Prerequisites
- Un proyecto de ```gatsby@4.15.0``` o superior.
- Establecer en **true** la opción **graphqlTypegen** en **gatsby-config.js**:
``` javascript
module.exports = {
    graphqlTypegen: true,
}
```
- Configurar ```"include": ["./src/**/*"]``` en el ```tsconfig.json```.

&nbsp;
&nbsp;

##### Using the autogenerated Queries types
1. Cuando usamos GraphQL Typegen veremos en la consola el mensaje 'Generating GraphQL and TypeScript types'.
2. Gatsby crea el archivo ```src/gatsby-types.d.ts```, que es quien contiene los types para las queries. Debemos **incluir** este archivo en ```tsconfig.json``` para poder acceder a 'namespace Query' en todos lados del proyecto.
3. Crear una página en ```src/pages/typegen.tsx``` con lo siguiente:

``` javascript
import * as React from 'react';
import { graphql, PageProps } from 'gatsby';

const TypegenPage = ({ data }: PageProps) => {

  return (
    <main style={pageStyles}>
      <p>Site title: TODO</p>
      <hr />
      <p>Query Result:</p>
      <pre>
        <code>{JSON.stringify(data, null, 2)}</code>
      </pre>
    </main>
  );

};

export default TypegenPage;

export const query = graphql`
  query TypegenPage {
    site {
      siteMetadata {
        title
      }
    }
  }
`;
```
Es **importante** que la query tenga un **nombre** (en este caso, query TypegenPage {}), ya que de otra forma, el 'automatic type generation' no funcionará. La gente de Gatsby recomienda nombrar la query con el mismo nombre que el componente, usando **PascalCase**.

4. Debemos declarar correctamente el tipado de la prop ```data``` de la siguiente manera:
``` javascript
({ data }: PageProps<Queries.TypegenPageQuery>)
```

&nbsp;
&nbsp;

##### Non-Nullable types
Como Gatsby *infiere todos campos* - Al menos que el usuario proporcione un esquema explícito -, ellos son *null* por defecto.
Para GraphQL Typegen esto significa que los campos pueden ser null. Sin embargo, utilizando 'Gatsby’s schema customization API' podemos modificar este comportamiento, para tipar explícitamente nuestros campos.

```gatsby-node.ts```

``` javascript
import { GatsbyNode } from 'gatsby';

export const createSchemaCustomization: GatsbyNode['createSchemaCustomization'] = ({ actions }) => {
  actions.createTypes(`
    type Site {
      siteMetadata: SiteMetadata!
    }

    type SiteMetadata {
      title: String!
    }
  `)
};
```

Para más información sobre cómo definir explícitamente los tipos: https://www.gatsbyjs.com/docs/reference/graphql-data-layer/schema-customization/

&nbsp;
&nbsp;

##### GraphQL fragments
Los 'fragments' le permiten reutilizar partes de las consultas de GraphQL. También le permite dividir consultas complejas en componentes más pequeños y fáciles de entender.
Más info: https://www.gatsbyjs.com/docs/reference/graphql-data-layer/using-graphql-fragments/

&nbsp;
&nbsp;

##### Tips
- Al usar ```gatsby-plugin-image```, se generan los tipos correctos para 'gatsbyImageData' y 'gatsbyImage' automáticamente.
- Se recomienda agregar ```src/gatsby-types.d.ts``` al ```.gitignore```, ya que es un código generado por máquina e información duplicada que ya existe, por ejemplo en las consultas de su página.

&nbsp;
&nbsp;

# **TypeScript and Gatsby**
___
&nbsp;
&nbsp;

##### Introduction
Gatsby acepta TypeScript de forma nativa, por lo que solo debemos reemplazar los ```.js``` / ```.jsx``` a ```.ts``` / ```.tsx``` para comenzar a utilizar Gatsby + TypeScript.

&nbsp;
&nbsp;

##### Initializing a new project with TypeScript
```npm init gatsby``` y respondemos las preguntas.
```npm init gatsby -ts``` para aclarar el uso de TypeScript.

&nbsp;
&nbsp;

##### Usage in Gatsby

###### PageProps
``` javascript
import type { PageProps } from 'gatsby';

const IndexRoute = ({ path }: PageProps) => {
  return (
    <main>
      <h1>Path: {path}</h1>
    </main>
  )
}

export default IndexRoute;
```

```PageProps``` can receive a couple of ```generics```, most notably the DataType one. This way you can type the resulting ```data``` prop. Others are: ```PageContextType```, ```LocationState```, and ```ServerDataType```.

``` javascript
import { graphql, PageProps } from 'gatsby';

type DataProps = {
  site: {
    siteMetadata: {
      title: string
    }
  }
};

const IndexRoute = ({ data: { site } }: PageProps<DataProps>) => {
  return (
    <main>
      <h1>{site.siteMetadata.title}</h1>
    </main>
  );
};

export default IndexRoute;

export const query = graphql`
  {
    site {
      siteMetadata {
        title
      }
    }
  }
`;
```

&nbsp;
&nbsp;

###### Gatsby Head API
You can use ``HeadProps`` to type your ``Gatsby Head API``.
&nbsp;

``` javascript
import type { HeadProps } from 'gatsby';

const Page = () => <div>Hello World</div>;

export default Page;

export const Head( props: HeadProps ) => ( <title>Hello World</title> );
```
&nbsp;

Similar to PageProps the HeadProps can receive two generics (DataType and PageContextType). This way you can type the data prop that gets passed to the Head function.
&nbsp;

``` javascript
import { graphql, HeadProps, PageProps } from 'gatsby';

type DataProps = {
  site: {
    siteMetadata: {
      title: string
    }
  }
};

const IndexRoute = ({ data: { site } }: PageProps<DataProps>) => {
  return (
    <main>
      <h1>{site.siteMetadata.title}</h1>
    </main>
  )
};

export default IndexRoute;

export function Head(props: HeadProps<DataProps>) {
  return (
    <title>{props.data.site.siteMetadata.title}</title>
  )
};

export const query = graphql`
  {
    site {
      siteMetadata {
        title
      }
    }
  }
`;
```

&nbsp;
If you’re using an anonymous function, you can also use the shorthand ``HeadFC`` type like this:
&nbsp;

``` javascript
export const Head: HeadFC<DataProps> = props => {
  // your return value
};
```

&nbsp;
&nbsp;

###### CSS Modules
To import CSS Modules add this typing definition to your source folder ``src/module.css.d.ts``: &nbsp;

``` javascript
declare module "*.module.css";
```

&nbsp;
&nbsp;

# **STYLING**
___
&nbsp;
&nbsp;

## Built-in CSS Support

Gatsby extends import so you can import CSS files directly into your components. ``src/pages/index.js``: &nbsp;

``` javascript
// Import from a CSS file in your src
import "../styles/index.css"
// Import from an installed package
import "bootstrap/dist/css/bootstrap.min.css"
```

Gatsby automatically concatenates and minifies CSS and inlines them into the <head> of your HTML files for the fastest possible page load time.

&nbsp;
##### Global CSS

CSS files with global styles like typography and colors are typically imported into the site’s ```gatsby-browser.js``` file.

&nbsp;
## Web fonts

&nbsp;
##### Using Google Fonts

1. Install the plugin and its peerDependencies:

``` javascript
npm install gatsby-omni-font-loader react-helmet
```

&nbsp;
2. Add the plugin to your ```gatsby-config.js```:

``` javascript
module.exports = {
  plugins: [
    {
      resolve: `gatsby-omni-font-loader`,
      options: {
        enableListener: true,
        preconnect: [`https://fonts.googleapis.com`, `https://fonts.gstatic.com`],
        web: [
          {
            name: `Open Sans`,
            file: `https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap`,
          },
        ],
      },
    },
  ]
}
```

&nbsp;
3. You can now reference the font in your CSS:

``` css
body {
  font-family: 'Open Sans';
}
```

&nbsp;
## Tailwind CSS

- Please follow the official [“Install Tailwind CSS with Gatsby”](https://tailwindcss.com/docs/guides/gatsby) guide to install and configure Tailwind CSS with Gatsby.
&nbsp;

- It is **not recommended** that you include Gatsby’s output directories (public and .cache) in your content array in your tailwind.config.js. You should only include your source files to have Tailwind working as expected.
&nbsp;

- If you use GraphQL Typegen a file at src/gatsby-types.d.ts will be generated and with the default configuration for content in tailwind.config.js this will trigger an infinite loop. You have two options to fix this:
&nbsp;

  1. Configure GraphQL Typegen’s [typesOutputPath option](https://www.gatsbyjs.com/docs/reference/config-files/gatsby-config/#graphqltypegen) to generate the file in another place.
  2. Adapt the ``content`` array to not include the ``src/gatsby-types.d.ts`` file, for example:
  &nbsp;

``` javascript
  // tailwind.config.js

  module.exports = {
    content: [
  -   "./src/**/*.{js,jsx,ts,tsx}",
  +   "./src/pages/*.{js,jsx,ts,tsx}",
  +   "./src/components/**/*.{js,jsx,ts,tsx}"
    ],
  }
```

&nbsp;
## Using Sass in Gatsby
In Gatsby, Sass code can be translated to well-formatted, standard CSS using a plugin.

1. Install the Gatsby plugin ``gatsby-plugin-sass`` and ``sass``:
``npm install sass gatsby-plugin-sass``

2. Include the plugin in your ``gatsby-config.js`` file.
``` javascript
plugins: [`gatsby-plugin-sass`],
```

3. Write your stylesheets as ``.scss`` files and require or import them as normal.

``` scss
  // styles.scss

$font-stack: Helvetica, sans-serif;
$primary-color: #333;

body {
  font: 100% $font-stack;
  color: $primary-color;
}
```

``` javascript
// src/components/navbar.js
import './styles.scss';
```

&nbsp;
&nbsp;

# **IMAGES AND MEDIA**
___
&nbsp;
&nbsp;

## Assets from filesystem

&nbsp;
##### Importing assets with webpack

With webpack you can import a file right in a JavaScript module.

To reduce the number of requests to the server, importing images that are less than 10,000 bytes returns a data URI instead of a path. This applies to the following file extensions: svg, jpg, jpeg, png, gif, mp4, webm, wav, mp3, m4a, aac, and oga.

Here’s an example:

``` javascript
  import logo from "./logo.png" // Tell webpack this JS file uses this image.
  console.log(logo) // /logo.84287d09.png

  const Header = () => {
    // Import result is the URL of your image
    return <img src={logo} alt="Logo" />
  }

  export default Header;
```

You can reference files in CSS to import them, too:

``` css
  .Logo {
    background-image: url(./logo.png);
  }
```

&nbsp;
##### Querying for a ``File`` in GraphQL using gatsby-source-filesystem

You can also import files using GraphQL by querying for them in your data layer, which will trigger copying of those files to the public directory. Querying for the publicURL field of File nodes will provide URLs you can use in your JavaScript components, pages and templates. Examples:

1. Copy all ``.pdf`` files you have in your data layer to your build directory and return URLs to them:

``` graphql
{
  allFile(filter: { extension: { eq: "pdf" } }) {
    edges {
      node {
        publicURL
      }
    }
  }
}
```

Reference those PDF files in a page with useStaticQuery:

``` javascript
import { useStaticQuery, graphql } from 'gatsby';
import Layout from '../components/layout';

const DownloadsPage = () => {

  const data = useStaticQuery(graphql`
    {
      allFile(filter: { extension: { eq: "pdf" } }) {
        edges {
          node {
            publicURL
            name
          }
        }
      }
    }
  `);

  return (
    <Layout>
      <h1>All PDF Downloads</h1>
      <ul>
        {data.allFile.edges.map((file, index) => {
          return (
            <li key={`pdf-${index}`}>
              <a href={file.node.publicURL} download>
                {file.node.name}
              </a>
            </li>
          )
        })}
      </ul>
    </Layout>
  );

};

export default DownloadsPage;
```

2. Link to attachments in the frontmatter of your Markdown files:

``` markdown
  ---
  title: "Title of article"
  attachments:
    - "./assets.zip"
    - "./presentation.pdf"
  ---

  Hi, this is a great article.
```

In an article template component file, you can then query for the attachments:

``` graphql
query ($slug: String!) {
  markdownRemark(fields: { slug: { eq: $slug } }) {
    html
    frontmatter {
      title
      attachments {
        publicURL
      }
    }
  }
}
```

&nbsp;
&nbsp;

In general, every website needs assets: images, stylesheets, scripts, etc. When using Gatsby, we recommend Importing Assets Directly in JavaScript files, because of the benefits it provides:

- Scripts and stylesheets are minified and bundled together to avoid extra network requests.
- Missing files cause compilation errors instead of 404 errors for your users.
- Result filenames include content hashes so you don’t need to worry about browsers caching their old versions.

&nbsp;
&nbsp;

# **QUERYING DATA**
___
&nbsp;
&nbsp;

## Page queries

feq

&nbsp;
##### Importing assets with webpack